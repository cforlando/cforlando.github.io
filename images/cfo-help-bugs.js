// Generated by CoffeeScript 1.9.3
(function() {
  var add_bug_to_list;

  add_bug_to_list = function(want_count, have_count, project_description, project_help_bugs_url, bugs, contributors_url) {
    var a, added_here, bug, header, headerlink, i, len, li, p, req;
    added_here = 0;
    li = document.createElement("li");
    headerlink = document.createElement("a");
    headerlink.setAttribute("href", project_help_bugs_url);
    headerlink.appendChild(document.createTextNode(project_description));
    header = document.createElement("h3");
    header.appendChild(headerlink);
    li.appendChild(header);
    bug_list.appendChild(li);
    for (i = 0, len = bugs.length; i < len; i++) {
      bug = bugs[i];
      if (have_count > (want_count + added_here)) {
        console.log("not adding any more bugs. We're full.");
        break;
      }
      a = document.createElement("a");
      a.setAttribute("href", bug.html_url);
      a.setAttribute("title", bug.description);
      a.appendChild(document.createTextNode(bug.title));
      p = document.createElement("p");
      p.appendChild(a);
      p.setAttribute("class", "bug");
      li.appendChild(p);
      added_here++;
    }
    return added_here;
    req = new XMLHttpRequest;
    return (function(avatarholder, contributors_url) {
      req.addEventListener("load", function() {
        var contributor, img, j, len1, ref, results;
        if (req.responseText) {
          ref = JSON.parse(req.responseText);
          results = [];
          for (j = 0, len1 = ref.length; j < len1; j++) {
            contributor = ref[j];
            img = document.createElement("img");
            img.setAttribute("src", contributor.avatar_url);
            img.setAttribute("title", contributor.login);
            img.setAttribute("class", "avatar");
            a = document.createElement("a");
            a.setAttribute("href", contributor.html_url);
            a.appendChild(img);
            results.push(avatarholder.appendChild(a));
          }
          return results;
        }
      });
      req.open("GET", contributors_url);
      return req.send();
    })(avatarholder, contributors_url);
  };

  document.fill_help_needed_bugs_list = function(repo_data_list) {
    var bug_list, contributors_url, have_count, i, issues_url, issues_url_description, len, project_description, project_page_url, repo_data, req, results, want_count;
    have_count = 0;
    want_count = 5;
    bug_list = document.getElementById("help-needed-bugs");
    if (bug_list) {
      results = [];
      for (i = 0, len = repo_data_list.length; i < len; i++) {
        repo_data = repo_data_list[i];
        project_description = repo_data[0], project_page_url = repo_data[1], issues_url_description = repo_data[2], contributors_url = repo_data[3];
        issues_url = issues_url_description.replace("{/number}", "?labels=help%20wanted");
        req = new XMLHttpRequest;
        results.push((function(req, project_description, project_page_url, issues_url, contributors_url) {
          req.addEventListener("load", function() {
            var added, bugs;
            if (have_count > want_count) {
              console.log("not adding any more bugs. We're full.");
              return;
            }
            if (req.responseText) {
              bugs = JSON.parse(req.responseText);
              if (bugs.length > 0) {
                added = add_bug_to_list(want_count, project_description, project_page_url + "/issues?q=is%3Aissue+is%3Aopen+label%3A%22help%20wanted%22", bugs, contributors_url);
                return have_count += added;
              }
            }
          });
          req.open("GET", issues_url, false);
          return req.send();
        })(req, project_description, project_page_url, issues_url, contributors_url));
      }
      return results;
    }
  };

}).call(this);
